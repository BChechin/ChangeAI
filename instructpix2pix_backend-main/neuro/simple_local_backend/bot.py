from collections import defaultdict

import PIL.Image
import logging
import os
import traceback
import uuid
from datetime import datetime
from enum import Enum
from pathlib import Path
from telegram import __version__ as TG_VER, BotCommand

from img_utils import print_result, crop_resize_for_sd
from sd_utils import remove_prompt_success_rate

try:
    from telegram import __version_info__
except ImportError:
    __version_info__ = (0, 0, 0, 0, 0)  # type: ignore[assignment]

if __version_info__ < (20, 0, 0, "alpha", 1):
    raise RuntimeError(
        f"This example is not compatible with your current PTB version {TG_VER}. To view the "
        f"{TG_VER} version of this example, "
        f"visit https://docs.python-telegram-bot.org/en/v{TG_VER}/examples.html"
    )
from telegram.ext import (
    CommandHandler,
    Application,
    ContextTypes,
    MessageHandler,
    filters,
)
from telegram import ForceReply, Update

from telegram.helpers import escape_markdown

from sd_utils import generate_image, generate_img2img, download_image, DEFAULT_IMAGE_GUIDANCE_SCALE, \
    DEFAULT_PROMPT_GUIDANCE_SCALE

# Enable logging
logger = logging.getLogger(__name__)


# todo: prepare commands list using all existing commands
def get_commands_list():
    return [
        BotCommand('start', 'Start the bot'),
        BotCommand('help', 'Get help'),
        BotCommand('help_ru', 'Get help, but with style!'),
        BotCommand('ping', 'Ping the bot'),
        BotCommand('imagine', '<prompt> Generate an image for the user prompt'),
        BotCommand('im', 'shortcut for /imagine'),
        # BotCommand('history', '<limit> Get a list of the last {limit} images generated by the user'),
        # BotCommand('h', 'shortcut for /history'),
        # BotCommand('get_image', '<id> Get a specific image by ID'),
    ]


class Bot:
    def __init__(self, token, sd_pipe, img2img_pipe, base_dir=''):
        logger.debug("Initializing bot...")

        self.generation_mode = {}  # user -> generation mode. Default = FROM_PROMPT
        self.images = defaultdict(list)  # user -> image
        self.sd_pipe = sd_pipe
        self.img2img_pipe = img2img_pipe
        self.base_dir = Path(base_dir)
        if not os.path.exists(self.images_path):
            os.makedirs(self.images_path)

        if not self.log_path.exists():
            with open(self.log_path, 'w') as f:
                f.write('user\tid\ttimestamp\timage_path\tprompt\n')

        self.application = Application.builder().token(token).post_init(self.post_init).build()
        self.setup()
        # todo: load earlier generated images on startup - (up to LIMIT=50 for each user?

    async def post_init(self, application: Application):
        await application.bot.set_my_commands(get_commands_list())

    def setup(self):
        self.application.add_error_handler(self.error_handler)

        # on different commands - answer in Telegram
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("help_ru", self.help_ru_command))
        self.application.add_handler(CommandHandler("ping", self.ping_command))
        # self.application.add_handler(CommandHandler(["history", 'h'], self.user_history_command))
        # self.application.add_handler(CommandHandler("get_image", self.get_image))

        # initialise SD
        # self.application.add_handler(CommandHandler("imagine", self.imagine_command))
        # self.application.add_handler(CommandHandler("im", self.imagine_command))
        self.application.add_handler(CommandHandler("imagine", self.chat_handler))
        self.application.add_handler(CommandHandler("im", self.imagine_command))

        self.application.add_handler(MessageHandler(filters.PHOTO, self.image_reactor))

        # Start the Bot
        # react to messages - generate!
        # on non command i.e message - echo the message on Telegram
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.chat_handler))

    # Define a few command handlers. These usually take the two arguments update and
    # context.
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a message when the command /start is issued."""
        user = update.effective_user
        message = rf"Hi {user.mention_html()}!" + "\n"
        message += """TL;DR: Send an image, tell what to do with it.
Some prompts work better than others. See examples at @BestChangeAi

This bot changes the image you send according to the prompt you specify.
How to use the bot:
1) Send a photo, in the caption of the image specify how to change it
2) Then you can just write what you want to change 
(or use <code>/imagine {prompt}</code> command) 
- the bot will apply it to the last image you sent

P.S. For instructions in Russian, use /help_ru"""
        # todo: add keanu reeves "make him old" meme
        await update.message.reply_html(
            message,
            reply_markup=ForceReply(selective=True),
        )

    async def help_ru_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a message when the command /help_ru is issued."""
        # Tran
        help_ru_message = """TL;DR: Шли фотку, говори что с ней делать
Некоторые инструкции работают лучше других. Примеры для вдохновения -  @BestChangeAi

Этот бот изменяет присланное вами изображение согласно вашей инструкции
Как пользоваться ботом:
1) Пришлите фото, в подписи к изображению укажите как его изменить
2) Дальше можно просто писать, что хотите изменить 
- бот будет применять его к последнему присланному вами изображению
(Если не работает на русском - пробуйте на английском)
        """
        await update.message.reply_text(help_ru_message)

    async def ping_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a message when the command /ping is issued."""
        await update.message.reply_text("pong!")

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Send a message when the command /help is issued."""
        # Translate to english:
        # help_ru_message = """
        # Этот бот изменяет присланное вами изображение
        # Как пользоватся ботом:
        # 1) Пришлите фото, в подписи к изображению укажите как его изменить
        # 2) Дальше можно просто писать, что хотите изменить
        # - бот будет применять его к последнему присланному вами изображению
        # (Если не работает на русском - пробуйте на английском)
        # """
        help_message = """TL;DR: Send an image, tell what to do with it.
Some prompts work better than others. See examples at @BestChangeAi

This bot changes the image you send
How to use the bot:
1) Send a photo, in the caption of the image, specify how to change it
2) Then you can just write what you want to change
- the bot will apply it to the last image you sent
        """
        await update.message.reply_text(help_message)

    async def error_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Log Errors caused by Updates."""
        # todo: save error traceback to the error history
        message = update.effective_message
        logger.warning('Update "%s" caused error "%s"', update, context.error, "traceback: ", traceback.format_exc())
        error_text = f'Error: {context.error}'
        await message.reply_text(f"Something went wrong :( {error_text}")

    async def main(self):
        async with self.application:
            await self.application.bot.set_my_commands(
                get_commands_list()
            )

    def run(self):
        self.application.run_polling()

    def generate_img2img(self, image, prompt, image_cfg: float = DEFAULT_IMAGE_GUIDANCE_SCALE,
                         prompt_cfg: float = DEFAULT_PROMPT_GUIDANCE_SCALE):
        logger.debug(f'Generating image from image: generate_img2img')
        # todo: parse parameters from prompt, if provided '--igs 0.5 --pgs 0.5'
        # prepare the image
        logger.debug(f'Resizing the image..')
        image = crop_resize_for_sd(image)

        # generate the image
        # todo: support num_images > 1
        logger.debug(f'Generating image...')
        res = generate_img2img(image=image, prompt=prompt, pipe=self.img2img_pipe,
                               prompt_guidance_scale=prompt_cfg, image_guidance_scale=image_cfg)
        res_image = res[0]

        logger.debug(f'Image generated, baking it to the original image and framing it...')
        # process the result
        res = print_result(image, res_image, prompt, prompt_cfg=prompt_cfg, image_cfg=image_cfg)
        res = res.convert('RGB')
        return res

    @property
    def images_path(self):
        return self.base_dir / 'images'

    @property
    def log_path(self):
        return self.base_dir / 'image_log.txt'

    @staticmethod
    def generate_id():
        """Generate a unique ID for the image. 8 symbols."""
        return uuid.uuid4().hex[:8]

    def generate_image_path(self, user, image_id, timestamp=None):
        if timestamp is None:
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        image_name = f'{user}_{timestamp}_{image_id}.jpg'
        return self.images_path / image_name

    def log_event(self, user, timestamp, prompt, image_path, img_id=None):
        if img_id is None:
            img_id = self.generate_id()
        with open(self.log_path, 'a') as f:
            f.write(f'{user}\t{img_id}\t{timestamp}\t{image_path}\t{prompt}\n')
        return img_id

    async def image_reactor(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if self.img2img_pipe is None:
            raise RuntimeError('Image to image model is not loaded')
        # get image
        file = await update.message.photo[-1].get_file()
        url = file.file_path
        image = download_image(url)
        user = update.effective_user.username
        logger.info(f"Request from user: {user}")
        logger.debug('File downloaded')
        # save image to memory
        self.images[user].append(image)
        # register that this was the last used command
        self.generation_mode[user] = GenerationMode.FROM_IMAGE
        prompt = update.message.caption
        if prompt is None:
            await update.effective_message.reply_text('Please, specify the prompt')
            return
        prompt = self.sanitize_prompt(prompt)
        # process image
        res_image = self.generate_img2img(image, prompt)
        logger.debug('Image generated. Saving...')

        # send image back

        image_id = str(uuid.uuid4())[:8]
        username = update.effective_user.username
        image_path = self.generate_image_path(username, image_id)
        res_image.save(image_path)
        logger.debug('Image sent. Sending...')
        with open(image_path, 'rb') as f:
            await update.message.reply_photo(f)

    @staticmethod
    def sanitize_prompt(prompt):
        prompt = remove_prompt_success_rate(prompt)
        return prompt

    async def reply_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """If user replies to a photo - use that photo for the generation instead"""
        pass

    async def forward_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """If user forwards a photo - use that photo for the generation instead"""
        # todo: capture the message that goes before forward somehow and use it as a prompt

    @property
    def resources_path(self):
        return Path(__file__).parent / 'resources'

    async def chat_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        # todo: use blank image, if no image is provided
        user = update.effective_user.username
        prompt = update.message.text
        if prompt.startswith('/'):
            prompt = prompt.split(None, 1)[1]
        prompt = prompt.strip()
        if not prompt:
            await update.effective_message.reply_text("Please provide a prompt")
            return
        prompt = self.sanitize_prompt(prompt)
        # generate image

        if self.images[user]:
            image = self.images[user][-1]
        else:
            # source_image_path = self.resources_path / 'default_source_image.jpg'
            source_image_path = self.resources_path / 'rickroll.jpg'
            image = PIL.Image.open(source_image_path)

        res_image = self.generate_img2img(image, prompt)
        # save image
        image_id = self.generate_id()
        username = update.effective_user.username
        image_path = self.generate_image_path(username, image_id)
        res_image.save(image_path)
        # send image back
        with open(image_path, 'rb') as f:
            await update.message.reply_photo(f)

    async def imagine_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if self.sd_pipe is None:
            raise RuntimeError("SD pipe is not initialised")
        prompt = update.message.text
        message = update.effective_message
        user = update.effective_user.username
        self.generation_mode[user] = GenerationMode.FROM_PROMPT
        # notify user that generation started
        # strip the command from the prompt
        info_message = "Generating image\.\.\. Takes about 1 minute\.\. __usually__\.\."
        if prompt.startswith('/'):
            if ' ' in prompt:
                prompt = prompt.split(' ', 1)[1]
            else:
                # todo: generate random interesting prompt
                # todo: using gpt-3
                prompt = "cosy warm winter evening in the forest " \
                         "after a snowfall with a cup of hot chocolate and a campfire"
                info_message += f"\n P\.S\. You forgot to add a prompt, so I generated one for you\.:\n" \
                                f"{escape_markdown(prompt, version=2)}"

        await message.reply_markdown_v2(info_message)
        # caputre errors and notify user
        image = generate_image(prompt=prompt, pipe=self.sd_pipe)
        # todo: send user progress updates

        username = update.effective_user.username
        timestamp = update.message.date
        timestamp_str = timestamp.strftime('%Y%m%d_%H%M%S')
        img_id = self.generate_id()
        # image_name = f'{username}_{timestamp_str}_{img_id}.jpg'
        image_path = self.generate_image_path(username, img_id, timestamp=timestamp_str)
        image.save(image_path)

        self.log_event(username, timestamp, prompt, image_path, img_id)

        with image_path.open('rb') as f:
            await message.reply_photo(f)

    def get_image_history(self, user):
        images = []
        with open(self.log_path, 'r') as f:
            for line in f:
                if line.startswith(user):
                    # user\tid\ttimestamp\timage_path\tprompt
                    images.append(line.strip().split('\t'))

        return images

    # command
    async def get_image(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Echo the user message."""
        username = update.effective_user.username
        message = update.message.text
        if message.startswith('/'):
            message = message.split(' ', 1)[1]
        image_id = message.strip()
        image_path = list(self.images_path.glob(f'{username}_*_{image_id}.jpg'))[0]

        with open(image_path, 'rb') as f:
            await update.message.reply_photo(f)

    async def user_history_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Echo the user message."""
        username = update.effective_user.username
        message = update.effective_message
        text = message.text
        if text.startswith('/'):
            if ' ' in text:
                text = text.split(' ', 1)[1].strip()
            else:
                text = ''
        if text:
            limit = int(text)
        else:
            limit = None
        images = self.get_image_history(username)
        msg = f'Your last {limit} images:\n'
        for username, id, timestamp, image_path, prompt in images[-limit:]:
            msg += f'{id} - {timestamp} - {prompt}\n'
        msg += "You can get a specific image by typing '/get_image <id>'"
        await message.reply_text(msg)


class GenerationMode(Enum):
    FROM_PROMPT = 1
    FROM_IMAGE = 2
